apply plugin: "java"

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath "org.apache.commons:commons-exec:1.3"
    }
}

subprojects {
    tasks.withType(JavaCompile) {
        //options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }
}

// ----------------------------------------------------------------------------
//                       global
// ----------------------------------------------------------------------------
import java.util.regex.Matcher
import java.util.regex.Pattern
import org.apache.commons.exec.CommandLine
import org.apache.commons.exec.DefaultExecutor
import org.apache.commons.exec.PumpStreamHandler

if (parseGradleVersion(gradle.gradleVersion) < 5) {
    logger.error("ERROR: Gradle Version MUST >= 5.0, current is {}", gradle.gradleVersion)
    throw new RuntimeException("ERROR: Gradle Version")
} else {
    logger.info("Gradle Version {}", gradle.gradleVersion)
}

def workdir = 'build/unzip_boot'
project.ext.rootWorkDir = new File(workdir).getAbsolutePath()
String activeImg = "boot.img"
String activePath = "/boot"
if (new File("boot.img").exists()) {
    activeImg = "boot.img"
    activePath = "/boot"
} else if (new File("recovery.img").exists()) {
    activeImg = "recovery.img"
    activePath = "/recovery"
} else if (new File("recovery-two-step.img").exists()) {
    activeImg = "recovery-two-step.img"
    activePath = "/boot"
} else if (new File("vbmeta.img").exists()) {
    activeImg = "vbmeta.img"
    activePath = "/vbmeta"
}
project.ext.outClearIMg = new File(String.format("%s.clear", activeImg)).getAbsolutePath()
project.ext.mkbootimgBin = new File("src/mkbootimg/mkbootimg").getAbsolutePath()
project.ext.mkbootfsBin = new File("mkbootfs/build/exe/mkbootfs/mkbootfs").getAbsolutePath()
project.ext.avbtool = new File("avb/avbtool").getAbsolutePath()
project.ext.bootSigner = new File("boot_signer/build/libs/boot_signer.jar").getAbsolutePath()
logger.warn("Active image target: " + activeImg)

// ----------------------------------------------------------------------------
//                       tasks
// ----------------------------------------------------------------------------
task unpack(type: JavaExec, dependsOn: ["bbootimg:jar"]) {
    classpath = sourceSets.main.runtimeClasspath
    main = "cfig.RKt"
    classpath = files("bbootimg/build/libs/bbootimg.jar")
    maxHeapSize '512m'
    args "unpack", activeImg, rootProject.mkbootimgBin, rootProject.avbtool, rootProject.bootSigner, rootProject.mkbootfsBin
}

task packClear(type: JavaExec, dependsOn: ["bbootimg:jar", "mkbootfs:mkbootfsExecutable"]) {
    classpath = sourceSets.main.runtimeClasspath
    main = "cfig.RKt"
    classpath = files("bbootimg/build/libs/bbootimg.jar")
    maxHeapSize '512m'
    args "pack", activeImg, rootProject.mkbootimgBin, rootProject.avbtool, rootProject.bootSigner, rootProject.mkbootfsBin
}

task sign(type: JavaExec, dependsOn: ["bbootimg:jar", packClear, "boot_signer:jar"]) {
    classpath = sourceSets.main.runtimeClasspath
    main = "cfig.RKt"
    classpath = files("bbootimg/build/libs/bbootimg.jar")
    maxHeapSize '4096m'
    args "sign", activeImg, rootProject.mkbootimgBin, rootProject.avbtool, rootProject.bootSigner, rootProject.mkbootfsBin
}

task signTest(type: JavaExec, dependsOn: ["boot_signer:jar"]) {
    main = 'com.android.verity.BootSignature'
    classpath = files("boot_signer/build/libs/boot_signer.jar")
    maxHeapSize '512m'
    args activePath, activeImg + '.clear', 'security/verity.pk8', 'security/verity.x509.pem', activeImg + '.signed', rootProject.mkbootfsBin
}

task pack(dependsOn: sign) {
    doLast {
        println("Pack task finished: " + activeImg + ".signed")
    }
}

task _setup(type: Copy) {
    from 'src/test/resources/boot.img'
    into '.'
}

task pull() {
    doFirst {
        println("Pulling ...")
    }

    doLast {
        String avb_version = adbCmd("getprop ro.boot.avb_version2")
        Boolean isAvbEnabled = false
        if (avb_version.isEmpty()) {
            isAvbEnabled = true
        }
        println("AVB: $isAvbEnabled")
        if (project.findProperty("group")) {
            println("Pull: $group")
        } else {
            println("Pull /boot, /recovery, /vbmeta")
            pullDefault(isAvbEnabled)
        }
    }
}

void pullDefault(Boolean avb = true) {
    Run(["adb", "shell", "dd if=/dev/block/by-name/boot of=/cache/boot.img"])
    Run(["adb", "shell", "dd if=/dev/block/by-name/recovery of=/cache/recovery.img"])
    if (avb) Run(["adb", "shell", "dd if=/dev/block/by-name/vbmeta of=/cache/vbmeta.img"])

    Run(["adb", "pull", "/cache/boot.img"])
    Run(["adb", "pull", "/cache/recovery.img"])
    if (avb) Run(["adb", "pull", "/cache/vbmeta.img"])

    Run(["adb", "shell", "rm /cache/boot.img"])
    Run(["adb", "shell", "rm /cache/recovery.img"])
    if (avb) Run(["adb", "shell", "rm /cache/vbmeta.img"])
}

void Run(List<String> inCmd, String inWorkdir = null) {
    println("CMD:" + inCmd)
    if (inWorkdir == null) {
        inWorkdir = ".";
    }
    ProcessBuilder pb = new ProcessBuilder(inCmd)
            .directory(new File(inWorkdir))
            .redirectErrorStream(true);
    Process p = pb.start()
    p.inputStream.eachLine { println it }
    p.waitFor();
    assert 0 == p.exitValue()
}

void Run(String inCmd, String inWorkdir = null) {
    Run(Arrays.asList(inCmd.split()), inWorkdir);
}

void updateBootImage(String activeImg) {
    String flashTarget = null;
    switch (activeImg) {
        case "boot.img":
        case "recovery-two-step.img":
            flashTarget = "/dev/block/by-name/boot";
            break;
        case "recovery.img":
            flashTarget = "/dev/block/by-name/recovery";
            break;
        case "vbmeta.img":
            flashTarget = "/dev/block/by-name/vbmeta";
            if (!new File(activeImg + ".signed").exists()) {
                return;
            }
            break;
    }
    Run("adb root")
    Run("adb push " + activeImg + ".signed /cache/")
    List<String> cmd2 = ["adb", "shell", "dd if=/cache/" + activeImg + ".signed of=" + flashTarget]
    Run(cmd2)
    cmd2 = ["adb", "shell", "rm -f /cache/" + activeImg + ".signed"];
    Run(cmd2)
}

task flash {
    doLast {
        updateBootImage(activeImg)
        updateBootImage("vbmeta.img")
    }
}

void rebootRecovery() {
    Run("adb reboot recovery")
}

task rr {
    doLast {
        rebootRecovery()
    }
}

task u(type: JavaExec, dependsOn: ["bbootimg:jar"]) {
    main = "cfig.packable.PackableLauncherKt"
    classpath = files("bbootimg/build/libs/bbootimg.jar")
    maxHeapSize '512m'
    args "unpack"
}

task p(type: JavaExec, dependsOn: ["bbootimg:jar", "mkbootfs:mkbootfsExecutable"]) {
    main = "cfig.packable.PackableLauncherKt"
    classpath = files("bbootimg/build/libs/bbootimg.jar")
    maxHeapSize '512m'
    args "pack"
}

int parseGradleVersion(String version) {
    Pattern VERSION_PATTERN = Pattern.compile("((\\d+)(\\.\\d+)+)(-(\\p{Alpha}+)-(\\w+))?(-(SNAPSHOT|\\d{14}([-+]\\d{4})?))?")
    Matcher matcher = VERSION_PATTERN.matcher(version)
    if (!matcher.matches()) {
        throw new IllegalArgumentException(format("'%s' is not a valid Gradle version string (examples: '1.0', '1.0-rc-1')", version))
    }
    String versionPart = matcher.group(1)
    int majorPart = Integer.parseInt(matcher.group(2), 10)
    logger.info("Gradle: versionPart {}, majorPart {}", versionPart, majorPart)
    return majorPart
}

String adbCmd(String cmd) {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream()
    def exec = new DefaultExecutor()
    exec.streamHandler = new PumpStreamHandler(outputStream)
    def cmdline = "adb shell $cmd"
    //println(cmdline)
    exec.execute(CommandLine.parse(cmdline))
    //println(outputStream)
    return outputStream.toString().trim()
}
